---
title: How to draw gears in WebGL
created: 07/20/2021
description: '@todo'
tags: javascript, webgl, react
cover_image: /images/cover-images/15_cover_image.jpg
cover_image_mobile: /images/cover-images/15_cover_image_mobile.jpg
cover_image_vert: /images/cover-images/15_cover_image_vert.jpg
cover_color: '#342A2C'
---

This article is the continuation of "[First steps in WebGL](https://aralroca.com/blog/first-steps-in-webgl)", where we saw [what it is and how it works](https://aralroca.com/blog/first-steps-in-webgl#what-is-webgl) internally: the [shaders](https://aralroca.com/blog/first-steps-in-webgl#glsl-and-shaders), the [program](https://aralroca.com/blog/first-steps-in-webgl#create-program-from-shaders), [buffers](https://aralroca.com/blog/first-steps-in-webgl#create-buffers), how to [link data from CPU to GPU](https://aralroca.com/blog/first-steps-in-webgl#create-buffers), and finally how to [render a triangle](https://aralroca.com/blog/first-steps-in-webgl#drawing-the-triangle). So to understand this article well, I recommend first reading the previous chapter.

In this article, instead of rendering a triangle, we will see how to render more complex structures and how to give it movement. So we'll implement three **dynamic gears**:

<img src="/images/blog-images/gears.gif" alt="Gears" class="center" />
<small class="center">Fig 1: gears generated by us in this article</small>

**We will cover the following:**

@todo

## Identifying shapes

The gears we want to draw are composed of **circles**. Among these circles there are certain varieties: circle with teeth, circle with colored border and circle filled with a color.

<img src="/images/blog-images/gear-shapes.png" alt="Indentifying gear shapes" class="center" />
<small class="center">Fig 2: three different circles</small>

Then we can confirm that we can draw these gears by drawing circles... But what's different about these circles? Oh, by the way, in the previous article we saw that with WebGL you can only rasterize triangles, points and lines... So, how do we make these circles? Let's see.

### Circle with border

To draw a circle with a border, we'll do it using multiple **points**:

<img src="/images/blog-images/stroke-circle.gif" alt="Circle with points" class="center" />
<small class="center">Fig 3: mouting a circle with 360 points</small>

### Circle with filled color

To draw a circle with a filled color, we'll do it using multiple **triangles**:

<img src="/images/blog-images/circle_triangle.gif" alt="Filled circle with triangle strip" class="center" />
<small class="center">Fig 4: filled circle with triangle strip</small>

The drawing mode that we are using is named **Triangle strip**:

> A triangle strip is a series of connected triangles from the triangle mesh, sharing vertices, allowing for more efficient memory usage for computer graphics. They are more efficient than triangle lists without indexing, but usually equally fast or slower than indexed triangle lists. The primary reason to use triangle strips is to reduce the amount of data needed to create a series of triangles. The number of vertices stored in memory is reduced from 3N to N+2, where N is the number of triangles to be drawn. This allows for less use of disk space, as well as making them faster to load into RAM.
> <small>Source: [Wikipedia](ttps://en.wikipedia.org/wiki/Triangle_strip#:~:text=A%20triangle%20strip%20is%20a,slower%20than%20indexed%20triangle%20lists.)</small>

### Circle with teeth

For the gear teeth we will also use **triangles**. But this time, without the "strip" mode. This way we will draw triangles that go from the center of the circumference to the outside.

<img src="/images/blog-images/teeth-shape.gif" alt="Teeth of gear" class="center" />
<small class="center">Fig 5: gear teeth are triangles</small>

It is important that when we create the teeth inside it has another circle filled with color to make the effect that the teeth are coming out of the circle itself.

## Identifying data to draw

One thing the 3 types of figures we need to draw have in common is that we can calculate their coordinates from 2 variables:

- Center of the circle (**x** and **y**)
- Radius

If we remember the previous article, we count that the coordinates within webGL go from -1 to 1. So let's to locate the centers of each piece of gear and its radius:

<br />
<img src="/images/blog-images/gears_coordinates.png" alt="Gears coordinates" class="center" />
<small class="center">Fig 6: sketch of the coordinates of the centers and the radius of each gear</small>

In addition, we have optional variables for specific figures such as:

- Number of teeth
- Stroke color _(color of the border)_
- Fill color
- Children _(more pieces of the same gear with the same data structure)_
- Direction of the rotation _(only valid for the parent)_

At the end, in JavaScript, we will have this array with the three gears data with all its pieces:

```js
const x1 = 0.1
const y1 = -0.2

const x2 = -0.42
const y2 = 0.41

const x3 = 0.56
const y3 = 0.28

export const gears = [
  {
    center: [x1, y1],
    direction: 'counterclockwise',
    numberOfTeeth: 20,
    radius: 0.45,
    fillColor: [0.878, 0.878, 0.878],
    children: [
      {
        center: [x1, y1],
        radius: 0.4,
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x1, y1],
        radius: 0.07,
        fillColor: [0.741, 0.741, 0.741],
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x1 - 0.23, y1],
        radius: 0.12,
        fillColor: [1, 1, 1],
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x1, y1 - 0.23],
        radius: 0.12,
        fillColor: [1, 1, 1],
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x1 + 0.23, y1],
        radius: 0.12,
        fillColor: [1, 1, 1],
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x1, y1 + 0.23],
        radius: 0.12,
        fillColor: [1, 1, 1],
        strokeColor: [0.682, 0.682, 0.682],
      },
    ],
  },
  {
    center: [x2, y2],
    direction: 'clockwise',
    numberOfTeeth: 12,
    radius: 0.3,
    fillColor: [0.741, 0.741, 0.741],
    children: [
      {
        center: [x2, y2],
        radius: 0.25,
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x2, y2],
        radius: 0.1,
        fillColor: [0.682, 0.682, 0.682],
        strokeColor: [0.6, 0.6, 0.6],
      },
    ],
  },
  {
    center: [x3, y3],
    direction: 'clockwise',
    numberOfTeeth: 6,
    radius: 0.15,
    fillColor: [0.741, 0.741, 0.741],
    children: [
      {
        center: [x3, y3],
        radius: 0.1,
        strokeColor: [0.682, 0.682, 0.682],
      },
      {
        center: [x3, y3],
        radius: 0.02,
        fillColor: [0.682, 0.682, 0.682],
        strokeColor: [0.6, 0.6, 0.6],
      },
    ],
  },
]
```

## How we will implement the rotation

Before we begin the implementation, we need to know how we are going to implement the rotation of each gear.

In order to understand the rotation and other linear transformations, I highly recommend the serie about **linear algebra** from [**3blue1brown**](https://www.youtube.com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) YouTube channel. In special, this video explains it very well:

<iframe class="center youtube" loading="lazy" src="https://www.youtube.com/embed/XkY2DOUCWMU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

To sum up, if we multiply our positions by any matrix, it receives a transformation. So we have to multiply each gear positions by the rotation matrix. We need to add every "transformation" in front of it, if we want to rotate, we will do `rotation * positions` instead of `positions * rotation`.

We can create the matrix we need to rotate by knowing the angle in radians:

```js
function rotation(angleInRadians = 0) {
  const c = Math.cos(angleInRadians)
  const s = Math.sin(angleInRadians)

  return [
    c, -s, 0,
    s, c, 0, 
    0, 0, 1
  ]
}
```

This way, we can make each gear turn differently. By multiplying the positions of each gear with its respective rotation matrix. To have a real rotation effect, in each frame we must increase the angle a little bit until it gives the complete turn and the angle returns to 0.

However, it is not enough to simply multiply our positions with this matrix. If you do, we will get this:

```glsl
rotation * position // It's not what we want.
```

<img src="/images/blog-images/rotation-incorrect.gif" class="center" alt="incorrect rotation" />
<small class="center">Fig 7: rotation on the canvas (not what we want)</small>

Well, we've got every gear doing its rotation... But the axis of rotation is always the center of the canvas, and that's incorrect. What we want is for them to rotate on their own center.

We must also multiply with translation matrices, to achieve rotation on the same axis.

The translation matrix can be defined as follows:

```js
function translation(tx, ty) {
  return [
    1, 0, 0,
    0, 1, 0, 
    tx, ty, 1
  ]
}
```

And we'll create two translation matrices: `translation(centerX, centerY)` and `translation(-centerX, -centerY)` to move to the origin.

So for the expected result, we will need to do this matrix multiplication:

```glsl
translation * rotation * translationToOrigin * position // Now they will turn on their axis
```

<img src="/images/blog-images/rotation-ok.gif" class="center" alt="correct rotation" />
<small class="center">Fig 8: self-rotation (what we want)</small>

Perhaps here we are wondering how to do that each gear spins at its own speed.

There's a simple formula for calculating the speed according to the number of teeth:

```
(Speed A * Number of teeth A) = (Speed B * Number of teeth B)
```

In this way, in each frame we can add a different angle step to each gear. In that way everyone spins at the speed that they're physically supposed to.

## Let's implement it!

Having reached this section, we now know:

- What figures we should draw and how.
- We have the coordinates of each gear and its parts.
- We know how to rotate each gear.

Let's see how to do it with JavaScript and GLSL.

### Initialize program with shaders

### Draw each frame + calculate rotation angles

### Draw gears

## Show me all the code

## Conclusion

In this article we have seen how to generate more complex figures using triangles and points. We have even given them movement with matrix multiplications.

As you have seen, there is a drawing mode that we have not seen yet, **lines**. The reason for this is because the lines that can be made are very thin, and they wouldn't fit the teeth of the gear. You can't change the thickness of the line easily, to do it you have to make a rectangle (2 triangles), so they have very little flexibility and most figures are drawn with triangles. Anyway, at this point, you should be able to use the `gl.LINES` given 2 coordinates.

This article was the second part of "First steps with WebGL". Stay tuned because in next articles of this series we will see: textures, image processing, framebuffers, 3d objects, and more.

## References

- https://www.youtube.com/watch?v=nlNOSNlTXEQ
- https://stackoverflow.com/a/54585370/4467741
- https://mattdesl.svbtle.com/drawing-lines-is-hard
- https://sudonull.com/post/69577-Drawing-thick-lines-in-WebGL
- https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
- https://webglfundamentals.org/webgl/lessons/webgl-2d-rotation.html
- http://www.corehtml5.com/trianglestripfundamentals.php
