---
title: Static Readme Regeneration
created: 07/29/2020
description: Use a cron with Github Actions to always have your GitHub README.md profile updated.
tags: webdev, rust
cover_image: /images/cover-images/14_cover_image.jpg
cover_image_mobile: /images/cover-images/14_cover_image_mobile.jpg
cover_image_vert: /images/cover-images/14_cover_image_vert.jpg
cover_color: '#98B0D7'
---

Recently GitHub introduced this "secret" feature to show a markdown template on your profile page. Surely, you've heard about this. All you need to do is create a repo with your username and have the `README.md` file there.

When we think of a template markdown on GitHub we normally think of static content. However, in this article I want to go a little further. So I'm going to tell you how to put content that is **updated from time to time**; whether it's your latest tweets, your latest youtube video, your latest blog posts, etc.

<img src="/images/blog-images/my-gh-profile.png" alt="My GH profile" class="center" />

<small class="center">My GitHub README profile under [aralroca](https://github.com/aralroca/aralroca) repo</small>

**We will cover the following:**

- [About Static Readme Regeneration (SRR)](#about-static-readme-regeneration-srr)
- [Implementation](#implementation)
  - [README.tpl](#readmetpl)
  - [Script to generate the README.md](#script-to-generate-the-readmemd)
  - [GitHub action with a cron](#github-action-with-a-cron)
- [Conclusion](#conclusion)
- [References](#references)

## About Static Readme Regeneration (SRR)

By "Static Readme Regeneration" I mean that the file `README.md` is generated by a script of ours, and then we update the content through a bot that every so often (programmed by us) makes a re-build of the `README.md`. The beauty of this is that the bot only commits to the repo if `README.md` has really changed. In this way the content of the README can be not entirely static, which can change every day, every hour, or even every minute.

In order to do this, we'll use a GitHub Action with a cron:

<img style="max-width: 700px" src="/images/blog-images/regeneration.png" alt="Static regeneration diagram for GitHub README profile" class="center" />

<small class="center">Diagram about static regeneration with GitHub Actions</small>

## Implementation

I'm going to explain the same example that I did in my profile. Always show the last 5 articles of my blog, and update it every day (if necessary). In this way I can relax, I know that when I upload a new post the `README.md` file of my profile will be automatically updated.

### README.tpl

Let's create a `README.md.tpl` file, the `.tpl` format is for template files. This file will contain all the static content of the `README.md`. Here we will write the markdown as if we would write it in the `README.md` file.

The only difference is that we will put what we want dynamic with some **interpolation symbols**. This way, our script can replace them with dynamic content.

<img style="max-width: 600px" src="/images/blog-images/tpl.png" alt="README.md.tpl diagram" class="center" />
<small class="center">Diagram about interpolation from <code>.md.tpl</code> to <code>.md</code></small>

### Script to generate the README.md

The script have to:

- Read the file `README.tpl.md`.
- Fetch all the posts from https://aralroca.com/rss.xml.
- Sort by `pub_date` + filter 5.
- Write the `README.md` file replacing the interpolation from `README.tpl.md` to the 5 articles as markdown string.

<br />
<img style="max-width: 600px" src="/images/blog-images/script.png" alt="Steps to implement" class="center" />

This can be implemented in any language; JavaScript, Rust, Python, Go, C... In this case I chose **Rust**, mostly because I have no experience with it and so I took the opportunity to learn a little _(feel free to create an issue on the repo if you are a Rust expert and see things that could be improved)_.

<small><b>> main.rs</b></small>

```rs
mod create_readme;

use create_readme::create_readme;

fn main() {
    match create_readme() {
        Ok(_v) => println!("README.md file generated correctly"),
        Err(e) => println!("Opps! there was an error: {:?}", e),
    }
}
```

<small><b>> create_readme.rs</b></small>

```rs
extern crate chrono;
extern crate rss;

use chrono::DateTime;
use rss::Channel;
use std::cmp::Ordering;
use std::fs;

struct FeedItem {
    title: String,
    link: String,
    pub_date: String,
}

pub fn create_readme() -> std::io::Result<()> {
    let tpl =
        fs::read_to_string("README.md.tpl")
        .expect("Something went wrong reading the README.tpl file");

    let last_articles = get_latest_articles();

    return fs::write(
        "README.md",
        tpl.replace("%{{latest_articles}}%", &last_articles),
    );
}

fn get_latest_articles() -> String {
    let mut posts: Vec<FeedItem> = get_blog_rss();

    // Sort articles by pub_date
    posts.sort_by(|a, b| {
        let date_a = DateTime::parse_from_rfc2822(&a.pub_date).unwrap();
        let date_b = DateTime::parse_from_rfc2822(&b.pub_date).unwrap();

        if date_b < date_a {
            Ordering::Less
        } else if date_b > date_a {
            Ordering::Greater
        } else {
            Ordering::Equal
        }
    });

    // Filter las 5 articles + format each one as markdown list string
    return posts[..5].iter().fold("".to_string(), |acc, item| {
        format!("{} \n* [{}]({})", acc, item.title, item.link)
    });
}

// Fetch all articles of my blog on rss.xml
fn get_blog_rss() -> Vec<FeedItem> {
    let items = Channel::from_url("https://aralroca.com/rss.xml")
        .unwrap()
        .items()
        .iter()
        .map(|item| FeedItem {
            title: item.title().unwrap().to_string(),
            link: item.link().unwrap().to_string(),
            pub_date: item.pub_date().unwrap().to_string(),
        })
        .collect();

    items
}
```
<br />

### GitHub Action with a cron

Once we have our script that does the build of our `README.md`, we just need to generate the cron using GitHub Action.

In order to create an Action, I recommend first to upload your script to the master branch, and then clicking the "Actions" tab of GitHub to create it. This way, GitHub detects the script language (Rust in our case) and creates a default yaml.

<img src="/images/blog-images/action-tab.png" alt="GitHub Actions tab" class="center" />

We are going to replace some things of the default yaml in order to:

* Schedule a cron
* Run the script *(`cargo run` instead of `cargo build && cargo test`)*
* Commit the regenerated README *(only if has changes)*

<small><b>> .github/workflows/rust.yml</b></small>

```yml
name: Rust

on:

  # Schedule a cron
  schedule:
    - cron: "0 0 */1 * *" #Â each day at 00:00 UTC

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build

    # Replace "cargo build" to "cargo run" to run the script
      run: cargo run

    # Commit the regenerated README only when it change 
    # (git diff --quiet && git diff --staged --quiet )
    - run: |
        git config user.name aralroca
        git config user.email aral-rg@hotmail.com
        git add README.md
        git diff --quiet && git diff --staged --quiet || git commit -m "[gh-action] Update README"
        git push origin master
```


## Conclusion

As a conclusion, we can see how thanks to the GitHub Actions we can take advantage of it to make our `README.md` always up to date. 

In most repos, the README file is always static, but now that this "secret" feature has come out on GitHub, you can show on your profile page your latest updates (releases, pr, tweets, posts, whatever...).

## References

- https://www.aboutmonica.com/blog/how-to-create-a-github-profile-readme
- https://github.com/midudev/midudev
